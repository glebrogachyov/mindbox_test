# Задание 1

Есть Pandas DataFrame со столбцами [“customer_id”, “product_id”, “timestamp”], который содержит данные по просмотрам товаров на сайте. Есть проблема – просмотры одного customer_id не разбиты на сессии (появления на сайте). Мы хотим разместить сессии так, чтобы сессией считались все смежные просмотры, между которыми не более 3 минут.

Написать методом который создаст в Pandas DataFrame столбец session_id и проставит в нем уникальный int id для каждой сессии.

У каждого пользователя может быть по несколько сессий. Исходный DataFrame может быть большим – до 100 млн строк.


## Файлы проекта

- main.py - содержит реализацию метода df.set_sessions(self), который принимает датафрейм, создает в нём столбец "session_id" и проставляет номера сессий
- set_session_test.py - содержит тесты к функции set_sessions(df)
- generate_test.py - содержит функцию generate_df, которая генерирует датафрейм и вызывает у него метод df.set_sessions(self)

## Описание решения

Метод инициализирует четыре пустых словаря, которые предназначены для хранения записей, произошедших в течение текущей минуты и 1-, 2-, 3 минут назад, более ранние события не хранятся в памяти.
Затем запускается итерация по строкам таблицы, если новая запись относится не к той же минуте, что и предыдущая, тогда удаляется информация за неактуальные минуты.
На каждой новой записи происходит проверка - совершал ли пользователь операции в течение последних трёх минут, если да - тогда в строку записывается тот же session_id,  что и у последней операции, если нет - тогда назначается новый уникальный session_id.

## Пояснение к решению

- Данное решение позволяет проставить id сессий в сколь угодно большой таблице, т.к. хранит только актуальную информацию.
- Для поиска записей используются словари - поиск нужных элементов производится быстро. 
- Т.к. данный файл скорее всего является логом, информация о временных метках должна быть записана в порядке поступления, было бы разумно не менять порядок записей и маркировать id сессий так же в хронологическом порядке. Данное решение не нарушает порядок следования записей и расставляет id сессий в соответствующем порядке, т.к. не использует никаких группировок или разбиений.
- Данное решение может работать с различными форматами данных customer_id, например, таким идентификатором может быть строка или ip-адрес пользователя, т.к. формат данных в условии явным образом не задан. В случае, если известно, что customer_id является целым числом в определённом диапазоне (например, несколько десятков тыс. пользователей), данное решение может быть модифицировано - словари стоит заменить на один большой массив (размером в число пользователей), хранящий записи о времени и session_id последней операции, где индекс элемента соответствует customer_id. В таком случае доступ к нужным данным будет моментальным, но будет использована дополнительная память.
